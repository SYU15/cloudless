{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cloudless :warning: :construction: :skull: This is a proof of concept, do not use in production. :skull: :construction: :warning: This tool should make it easier to interact with cloud resources by doing most of the work that a human doesn't need to care about for you, and by being transparent about what it's doing. Installation This project depends on Python 3.6.0 or greater. It can be installed as a normal python package using pip, but an environment manager such as pipenv is recommended. To install locally, make a dedicated directory where you want to test this out and run: cd cloudless_experimentation pipenv install git+https://github.com/sverch/cloudless.git#egg=cloudless Having a dedicated directory will allow pipenv to scope the dependencies to that project directory and prevent this project from installing stuff on your main system. Client Setup First, you must create a client object to connect to the cloud platform that you'll be working with. The client handles authentication with the cloud provider, so you must pass it the name of the provider and the authentication credentials. If you are trying this project for the first time, it's recommended that you use the \"mock-aws\" client. Google Compute Engine Client To use the Google Compute Engine client, you must create a service account and download the credentials locally. Because this provider is implemented using Apache Libcloud , you can refer to the Google Compute Engine Driver Setup documentation in that project for more details. When you have the credentials, you can do something like this, preferably in a dotfile you don't commit to version control. Note the credentials file is in JSON format: export BUTTER_GCE_USER_ID=\"sverch-cloudless@cloudless-000000.iam.gserviceaccount.com\" export BUTTER_GCE_CREDENTIALS_PATH=\"/home/sverch/.gce/credentials.json\" export BUTTER_GCE_PROJECT_NAME=\"cloudless-000000\" Then, you can run these commands in a python shell to create a GCE client: import cloudless import os client = cloudless.Client(\"gce\", credentials={ \"user_id\": os.environ['BUTTER_GCE_USER_ID'], \"key\": os.environ['BUTTER_GCE_CREDENTIALS_PATH'], \"project\": os.environ['BUTTER_GCE_PROJECT_NAME']}) Amazon Web Services Client Currently no credentials can be passed in as arguments for the AWS provider (they are ignored). However this provider is implemented with Boto , which looks in many other places for the credentials, so you can configure them in other ways. See the boto3 credential setup documentation for more details. Once you have set up your credentials, you can run the following to create an AWS client: import cloudless client = cloudless.Client(\"aws\", credentials={}) Mock Amazon Web Services Client The Mock AWS client is for demonstration and testing. Since it is all running locally, you don't need any credentials. Simply run: import cloudless client = cloudless.Client(\"mock-aws\", credentials={}) Architecture There are only three objects in Cloudless: A Network, a Service, and a Path. This is an example that shows a Network dev , a public_load_balancer Service, an internal_service Service, a Path from the internet to public_load_balancer on port 443, and a Path from public_load_balancer to internal_service on port 80. See the visualization section for how to generate this graph. Network A Network is the top level container for everything else. To create a new network, run: dev_network = client.network.create(\"dev\") This will return the \"Network\" object that describes the network that was created. You can retrieve an existing network or list all existing networks by running: dev_network = client.network.get(\"dev\") all_networks = client.network.list() Finally, to destroy a network: client.network.destroy(dev_network) Create should use sane defaults, but if you need to do something special see docs/network-configuration.md . In ipython , you can run <object>? to get help on any object , for example client.network.create? . Service A Service a logical group of instances and whatever resources are needed to support them (subnetworks, firewalls, etc.). To create a Service, you must first define a configuration file called a \"blueprint\" that specifies how the service should be configured. This is an example of what a Service blueprint might look like: --- network: subnetwork_max_instance_count: 768 placement: availability_zones: 3 instance: public_ip: True memory: 4GB cpus: 1 gpu: false disks: - size: 8GB type: standard device_name: /dev/sda1 image: name: \"ubuntu/images/hvm-ssd/ubuntu-xenial-16.04-amd64-server-*\" initialization: - path: \"haproxy-cloud-config.yml\" vars: PrivateIps: required: true The \"network\" section tells Cloudless to create subnetworks for this service big enough for 768 instances. The \"placement\" section tells Cloudless to ensure instances in this service are provisioned across three availaibility zones (which most cloud providers guarantee are meaningfully isolated from each other for resilience). The \"instance\" section describes the resource reqirements of each instance. Cloudless will automatically choose a instance type that meets these requirements. The \"image\" section represents the name of the image you want your instances to have. In this case, we are using an image name only found in AWS by default, so this example will only work there. See example-blueprints/gce-apache for a GCE example blueprint. The \"initialization\" section describes startup scripts that you want to run when the instance boots. You may also pass in variables, which will get passed to the given file as jinja2 template arguments. This is a good place to specify environment specific configuration, so your base image can stay the same across environments. Once you have the blueprint, the example below shows how you could use it. These examples create a group of private instances and then create some HAProxy instances in front of those instances to balance load. Note that many commands take dev_network as the first argument. That's the same network object returned by the network commands shown above. internal_service = client.service.create(dev_network, \"private\", blueprint=\"example-blueprints/aws-nginx/blueprint.yml\") private_ips = [instance.private_ip for instance in client.service.get_instances(internal_service)] load_balancer_service = client.service.create(dev_network, \"public\", blueprint=\"example-blueprints/aws-haproxy/blueprint.yml\", template_vars={\"PrivateIps\": private_ips}) internal_service = client.service.get(dev_network, \"public\") load_balancer_service client.service.get(dev_network, \"private\") client.service.list() client.service.destroy(internal_service) client.service.destroy(load_balancer_service) There is another example blueprint that works with GCE if you created the GCE client above: client.instances.create(dev_nework, \"public\", blueprint=\"example-blueprints/gce-apache/blueprint.yml\") Path The Path is how you tell Cloudless that two services should be able to communicate. No blueprint is needed for this, but you need to have the service objects you created earlier. This example adds a path from the load balancer to the internal service on port 80 and makes the load balancer internet accessible on port 443: from cloudless.types.networking import CidrBlock internet = CidrBlock(\"0.0.0.0/0\") client.paths.add(load_balancer_service, internal_service, 80) client.paths.add(internet, load_balancer_service, 443) You can check whether things have access to other things or print out all paths with the following functions: client.paths.has_access(load_balancer_service, internal_service, 80) client.paths.internet_accessible(load_balancer_service, 443) client.paths.internet_accessible(internal_service, 443) client.paths.list() print(client.graph()) Visualization Get a summary in the form of a graphviz compatible dot file by running: client.graph() To generate the vizualizations, run: cd ui && env PROVIDER=<provider> bash graph.sh And open ui/graph.html in a browser. Note this won't work for the mock-aws provider since it will be running in a different process. Blueprint Tester This project also provides a framework to help test that blueprint files work as expected. Example (cloudless must be installed): cloudless-test --provider aws --blueprint_dir example-blueprints/haproxy run Run cloudless-test with no arguments for usage. This runner tries to import blueprint_fixture.BlueprintTest from the root of your blueprint directory. This must be a class that inherits from cloudless.testutils.fixture.BlueprintTestInterface and implements all the required methods. See the documentation on that class for usage details. The runner expects the blueprint file that you are testing to be name blueprint.yml in the blueprint directory. See example-blueprints for all examples. Testing To run the local tests run: pipenv install --dev tox To run tests against GCE and AWS, run: tox -e gce tox -e aws For GCE, you must set BUTTER_GCE_USER_ID , BUTTER_GCE_CREDENTIALS_PATH , and BUTTER_GCE_PROJECT_NAME as described above.","title":"Home"},{"location":"#cloudless","text":":warning: :construction: :skull: This is a proof of concept, do not use in production. :skull: :construction: :warning: This tool should make it easier to interact with cloud resources by doing most of the work that a human doesn't need to care about for you, and by being transparent about what it's doing.","title":"Cloudless"},{"location":"#installation","text":"This project depends on Python 3.6.0 or greater. It can be installed as a normal python package using pip, but an environment manager such as pipenv is recommended. To install locally, make a dedicated directory where you want to test this out and run: cd cloudless_experimentation pipenv install git+https://github.com/sverch/cloudless.git#egg=cloudless Having a dedicated directory will allow pipenv to scope the dependencies to that project directory and prevent this project from installing stuff on your main system.","title":"Installation"},{"location":"#client-setup","text":"First, you must create a client object to connect to the cloud platform that you'll be working with. The client handles authentication with the cloud provider, so you must pass it the name of the provider and the authentication credentials. If you are trying this project for the first time, it's recommended that you use the \"mock-aws\" client.","title":"Client Setup"},{"location":"#google-compute-engine-client","text":"To use the Google Compute Engine client, you must create a service account and download the credentials locally. Because this provider is implemented using Apache Libcloud , you can refer to the Google Compute Engine Driver Setup documentation in that project for more details. When you have the credentials, you can do something like this, preferably in a dotfile you don't commit to version control. Note the credentials file is in JSON format: export BUTTER_GCE_USER_ID=\"sverch-cloudless@cloudless-000000.iam.gserviceaccount.com\" export BUTTER_GCE_CREDENTIALS_PATH=\"/home/sverch/.gce/credentials.json\" export BUTTER_GCE_PROJECT_NAME=\"cloudless-000000\" Then, you can run these commands in a python shell to create a GCE client: import cloudless import os client = cloudless.Client(\"gce\", credentials={ \"user_id\": os.environ['BUTTER_GCE_USER_ID'], \"key\": os.environ['BUTTER_GCE_CREDENTIALS_PATH'], \"project\": os.environ['BUTTER_GCE_PROJECT_NAME']})","title":"Google Compute Engine Client"},{"location":"#amazon-web-services-client","text":"Currently no credentials can be passed in as arguments for the AWS provider (they are ignored). However this provider is implemented with Boto , which looks in many other places for the credentials, so you can configure them in other ways. See the boto3 credential setup documentation for more details. Once you have set up your credentials, you can run the following to create an AWS client: import cloudless client = cloudless.Client(\"aws\", credentials={})","title":"Amazon Web Services Client"},{"location":"#mock-amazon-web-services-client","text":"The Mock AWS client is for demonstration and testing. Since it is all running locally, you don't need any credentials. Simply run: import cloudless client = cloudless.Client(\"mock-aws\", credentials={})","title":"Mock Amazon Web Services Client"},{"location":"#architecture","text":"There are only three objects in Cloudless: A Network, a Service, and a Path. This is an example that shows a Network dev , a public_load_balancer Service, an internal_service Service, a Path from the internet to public_load_balancer on port 443, and a Path from public_load_balancer to internal_service on port 80. See the visualization section for how to generate this graph.","title":"Architecture"},{"location":"#network","text":"A Network is the top level container for everything else. To create a new network, run: dev_network = client.network.create(\"dev\") This will return the \"Network\" object that describes the network that was created. You can retrieve an existing network or list all existing networks by running: dev_network = client.network.get(\"dev\") all_networks = client.network.list() Finally, to destroy a network: client.network.destroy(dev_network) Create should use sane defaults, but if you need to do something special see docs/network-configuration.md . In ipython , you can run <object>? to get help on any object , for example client.network.create? .","title":"Network"},{"location":"#service","text":"A Service a logical group of instances and whatever resources are needed to support them (subnetworks, firewalls, etc.). To create a Service, you must first define a configuration file called a \"blueprint\" that specifies how the service should be configured. This is an example of what a Service blueprint might look like: --- network: subnetwork_max_instance_count: 768 placement: availability_zones: 3 instance: public_ip: True memory: 4GB cpus: 1 gpu: false disks: - size: 8GB type: standard device_name: /dev/sda1 image: name: \"ubuntu/images/hvm-ssd/ubuntu-xenial-16.04-amd64-server-*\" initialization: - path: \"haproxy-cloud-config.yml\" vars: PrivateIps: required: true The \"network\" section tells Cloudless to create subnetworks for this service big enough for 768 instances. The \"placement\" section tells Cloudless to ensure instances in this service are provisioned across three availaibility zones (which most cloud providers guarantee are meaningfully isolated from each other for resilience). The \"instance\" section describes the resource reqirements of each instance. Cloudless will automatically choose a instance type that meets these requirements. The \"image\" section represents the name of the image you want your instances to have. In this case, we are using an image name only found in AWS by default, so this example will only work there. See example-blueprints/gce-apache for a GCE example blueprint. The \"initialization\" section describes startup scripts that you want to run when the instance boots. You may also pass in variables, which will get passed to the given file as jinja2 template arguments. This is a good place to specify environment specific configuration, so your base image can stay the same across environments. Once you have the blueprint, the example below shows how you could use it. These examples create a group of private instances and then create some HAProxy instances in front of those instances to balance load. Note that many commands take dev_network as the first argument. That's the same network object returned by the network commands shown above. internal_service = client.service.create(dev_network, \"private\", blueprint=\"example-blueprints/aws-nginx/blueprint.yml\") private_ips = [instance.private_ip for instance in client.service.get_instances(internal_service)] load_balancer_service = client.service.create(dev_network, \"public\", blueprint=\"example-blueprints/aws-haproxy/blueprint.yml\", template_vars={\"PrivateIps\": private_ips}) internal_service = client.service.get(dev_network, \"public\") load_balancer_service client.service.get(dev_network, \"private\") client.service.list() client.service.destroy(internal_service) client.service.destroy(load_balancer_service) There is another example blueprint that works with GCE if you created the GCE client above: client.instances.create(dev_nework, \"public\", blueprint=\"example-blueprints/gce-apache/blueprint.yml\")","title":"Service"},{"location":"#path","text":"The Path is how you tell Cloudless that two services should be able to communicate. No blueprint is needed for this, but you need to have the service objects you created earlier. This example adds a path from the load balancer to the internal service on port 80 and makes the load balancer internet accessible on port 443: from cloudless.types.networking import CidrBlock internet = CidrBlock(\"0.0.0.0/0\") client.paths.add(load_balancer_service, internal_service, 80) client.paths.add(internet, load_balancer_service, 443) You can check whether things have access to other things or print out all paths with the following functions: client.paths.has_access(load_balancer_service, internal_service, 80) client.paths.internet_accessible(load_balancer_service, 443) client.paths.internet_accessible(internal_service, 443) client.paths.list() print(client.graph())","title":"Path"},{"location":"#visualization","text":"Get a summary in the form of a graphviz compatible dot file by running: client.graph() To generate the vizualizations, run: cd ui && env PROVIDER=<provider> bash graph.sh And open ui/graph.html in a browser. Note this won't work for the mock-aws provider since it will be running in a different process.","title":"Visualization"},{"location":"#blueprint-tester","text":"This project also provides a framework to help test that blueprint files work as expected. Example (cloudless must be installed): cloudless-test --provider aws --blueprint_dir example-blueprints/haproxy run Run cloudless-test with no arguments for usage. This runner tries to import blueprint_fixture.BlueprintTest from the root of your blueprint directory. This must be a class that inherits from cloudless.testutils.fixture.BlueprintTestInterface and implements all the required methods. See the documentation on that class for usage details. The runner expects the blueprint file that you are testing to be name blueprint.yml in the blueprint directory. See example-blueprints for all examples.","title":"Blueprint Tester"},{"location":"#testing","text":"To run the local tests run: pipenv install --dev tox To run tests against GCE and AWS, run: tox -e gce tox -e aws For GCE, you must set BUTTER_GCE_USER_ID , BUTTER_GCE_CREDENTIALS_PATH , and BUTTER_GCE_PROJECT_NAME as described above.","title":"Testing"},{"location":"client/","text":"cloudless Cloudless This is a python library to provide a basic set of easy to use primitive operations that can work with many different cloud providers. These primitives are: - Create a \"Network\" (also known as VPC, Network, Environment). e.g. \"dev\". - Create a \"Service\" within that network. e.g. \"apache-public\". - Easily control network connections and firewalls. The goal is to provide an intuitive abstraction that is powerful enough to build on, so that building other layers on top is easy and anything built on it is automatically cross cloud. Client Client(self, provider, credentials) Cloudless Client Object This is the object through which all calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) client.network.* client.paths.* See the documentation on those sub-components for more details. graph Client.graph(self) Return a human readable formatted string representation of the paths graph. NetworkClient NetworkClient(self, provider, credentials) Cloudless Network Client Object This is the object through which all network related calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) client.network.create(\"network\", blueprint=\"tests/blueprints/network.yml\") client.network.get(\"network\") client.network.list() client.network.destroy(client.network.get(\"network\")) The above commands will create and destroy a network named \"network\". create NetworkClient.create(self, name, blueprint=None) Create new network named \"name\" with blueprint file at \"blueprint\". Example: client.network.create(\"mynetwork\", \"network-blueprint.yml\") get NetworkClient.get(self, name) Get a network named \"name\" and return some data about it. Example: client.network.get(\"mynetwork\") destroy NetworkClient.destroy(self, network) Destroy the given network. Example: client.network.destroy(client.network.get(\"mynetwork\")) list NetworkClient.list(self) List all networks. Example: client.network.list() ServiceClient ServiceClient(self, provider, credentials) Cloudless Service Client Object This is the object through which all service related calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) network = client.network.create(\"network\", blueprint=\"tests/blueprints/network.yml\") client.service.create(network, \"public\", blueprint=\"tests/blueprints/service.yml\") myservice = client.service.get(mynetwork, \"public\") client.service.list() client.service.destroy(myservice) The above commands will create and destroy a service named \"public\" in the network \"network\". create ServiceClient.create(self, network, service_name, blueprint, template_vars=None, count=None) Create a service in \"network\" named \"service_name\" with blueprint file at \"blueprint\". \"template_vars\" are passed to the initialization scripts as jinja2 variables. get ServiceClient.get(self, network, service_name) Get a service in \"network\" named \"service_name\". get_instances ServiceClient.get_instances(self, service) Helper to return the list of instances given a service object. destroy ServiceClient.destroy(self, service) Destroy a service described by the \"service\" object. list ServiceClient.list(self) List all services. node_types ServiceClient.node_types(self) Get mapping of node types to the resources. PathsClient PathsClient(self, provider, credentials) Cloudless Paths Client Object This is the object through which all path related calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) internal_service = client.service.get(network, \"internal_service\") load_balancer = client.service.get(network, \"load_balancer\") internet = CidrBlock(\"0.0.0.0/0\") client.paths.add(load_balancer, internal_service, 80) client.paths.add(internet, load_balancer, 443) client.paths.list() client.graph() The above commands will result in the public internet having access to \"load_balancer\" on port 443 and \"load_balancer\" having access to \"internal_service\" on port 80. add PathsClient.add(self, source, destination, port) Make the service or cidr block described by \"destination\" accessible from the service or cidr block described by \"source\" on the given port. Either \"source\" or \"destination\" must be a service object. remove PathsClient.remove(self, source, destination, port) Ensure the service or cidr block described by \"destination\" is not accessible from the service or cidr block described by \"source\" on the given port. Either \"source\" or \"destination\" must be a service object. list PathsClient.list(self) List all paths and return a dictionary structure representing a graph. internet_accessible PathsClient.internet_accessible(self, service, port) Returns true if the service described by \"service\" is internet accessible on the given port. has_access PathsClient.has_access(self, source, destination, port) Returns true if the service or cidr block described by \"destination\" is accessible from the service or cidr block described by \"source\" on the given port. Either \"source\" or \"destination\" must be a service object.","title":"Client"},{"location":"client/#cloudless","text":"Cloudless This is a python library to provide a basic set of easy to use primitive operations that can work with many different cloud providers. These primitives are: - Create a \"Network\" (also known as VPC, Network, Environment). e.g. \"dev\". - Create a \"Service\" within that network. e.g. \"apache-public\". - Easily control network connections and firewalls. The goal is to provide an intuitive abstraction that is powerful enough to build on, so that building other layers on top is easy and anything built on it is automatically cross cloud.","title":"cloudless"},{"location":"client/#client","text":"Client(self, provider, credentials) Cloudless Client Object This is the object through which all calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) client.network.* client.paths.* See the documentation on those sub-components for more details.","title":"Client"},{"location":"client/#graph","text":"Client.graph(self) Return a human readable formatted string representation of the paths graph.","title":"graph"},{"location":"client/#networkclient","text":"NetworkClient(self, provider, credentials) Cloudless Network Client Object This is the object through which all network related calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) client.network.create(\"network\", blueprint=\"tests/blueprints/network.yml\") client.network.get(\"network\") client.network.list() client.network.destroy(client.network.get(\"network\")) The above commands will create and destroy a network named \"network\".","title":"NetworkClient"},{"location":"client/#create","text":"NetworkClient.create(self, name, blueprint=None) Create new network named \"name\" with blueprint file at \"blueprint\". Example: client.network.create(\"mynetwork\", \"network-blueprint.yml\")","title":"create"},{"location":"client/#get","text":"NetworkClient.get(self, name) Get a network named \"name\" and return some data about it. Example: client.network.get(\"mynetwork\")","title":"get"},{"location":"client/#destroy","text":"NetworkClient.destroy(self, network) Destroy the given network. Example: client.network.destroy(client.network.get(\"mynetwork\"))","title":"destroy"},{"location":"client/#list","text":"NetworkClient.list(self) List all networks. Example: client.network.list()","title":"list"},{"location":"client/#serviceclient","text":"ServiceClient(self, provider, credentials) Cloudless Service Client Object This is the object through which all service related calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) network = client.network.create(\"network\", blueprint=\"tests/blueprints/network.yml\") client.service.create(network, \"public\", blueprint=\"tests/blueprints/service.yml\") myservice = client.service.get(mynetwork, \"public\") client.service.list() client.service.destroy(myservice) The above commands will create and destroy a service named \"public\" in the network \"network\".","title":"ServiceClient"},{"location":"client/#create_1","text":"ServiceClient.create(self, network, service_name, blueprint, template_vars=None, count=None) Create a service in \"network\" named \"service_name\" with blueprint file at \"blueprint\". \"template_vars\" are passed to the initialization scripts as jinja2 variables.","title":"create"},{"location":"client/#get_1","text":"ServiceClient.get(self, network, service_name) Get a service in \"network\" named \"service_name\".","title":"get"},{"location":"client/#get_instances","text":"ServiceClient.get_instances(self, service) Helper to return the list of instances given a service object.","title":"get_instances"},{"location":"client/#destroy_1","text":"ServiceClient.destroy(self, service) Destroy a service described by the \"service\" object.","title":"destroy"},{"location":"client/#list_1","text":"ServiceClient.list(self) List all services.","title":"list"},{"location":"client/#node_types","text":"ServiceClient.node_types(self) Get mapping of node types to the resources.","title":"node_types"},{"location":"client/#pathsclient","text":"PathsClient(self, provider, credentials) Cloudless Paths Client Object This is the object through which all path related calls are made. Usage: import cloudless client = cloudless.Client(provider, credentials) internal_service = client.service.get(network, \"internal_service\") load_balancer = client.service.get(network, \"load_balancer\") internet = CidrBlock(\"0.0.0.0/0\") client.paths.add(load_balancer, internal_service, 80) client.paths.add(internet, load_balancer, 443) client.paths.list() client.graph() The above commands will result in the public internet having access to \"load_balancer\" on port 443 and \"load_balancer\" having access to \"internal_service\" on port 80.","title":"PathsClient"},{"location":"client/#add","text":"PathsClient.add(self, source, destination, port) Make the service or cidr block described by \"destination\" accessible from the service or cidr block described by \"source\" on the given port. Either \"source\" or \"destination\" must be a service object.","title":"add"},{"location":"client/#remove","text":"PathsClient.remove(self, source, destination, port) Ensure the service or cidr block described by \"destination\" is not accessible from the service or cidr block described by \"source\" on the given port. Either \"source\" or \"destination\" must be a service object.","title":"remove"},{"location":"client/#list_2","text":"PathsClient.list(self) List all paths and return a dictionary structure representing a graph.","title":"list"},{"location":"client/#internet_accessible","text":"PathsClient.internet_accessible(self, service, port) Returns true if the service described by \"service\" is internet accessible on the given port.","title":"internet_accessible"},{"location":"client/#has_access","text":"PathsClient.has_access(self, source, destination, port) Returns true if the service or cidr block described by \"destination\" is accessible from the service or cidr block described by \"source\" on the given port. Either \"source\" or \"destination\" must be a service object.","title":"has_access"},{"location":"providers/","text":"cloudless.providers Backend Providers Each directory in this directory should be a single supported backend provider.","title":"Providers"},{"location":"providers/#cloudlessproviders","text":"Backend Providers Each directory in this directory should be a single supported backend provider.","title":"cloudless.providers"},{"location":"providers/aws/","text":"cloudless.providers.aws AWS Provider This module implements support for using AWS as a backing provider.","title":"Amazon Web Services"},{"location":"providers/aws/#cloudlessprovidersaws","text":"AWS Provider This module implements support for using AWS as a backing provider.","title":"cloudless.providers.aws"},{"location":"providers/gce/","text":"cloudless.providers.gce GCE Provider This module implements support for using GCE as a backing provider.","title":"Google Compute Engine"},{"location":"providers/gce/#cloudlessprovidersgce","text":"GCE Provider This module implements support for using GCE as a backing provider.","title":"cloudless.providers.gce"},{"location":"providers/mock_aws/","text":"cloudless.providers.aws_mock Mock AWS Provider This module uses AWS as a backing provider with moto instead of boto3 so that no resources get deployed.","title":"Mock Amazon Web Services"},{"location":"providers/mock_aws/#cloudlessprovidersaws_mock","text":"Mock AWS Provider This module uses AWS as a backing provider with moto instead of boto3 so that no resources get deployed.","title":"cloudless.providers.aws_mock"}]}